# RPC
    有多种方式实现远程过程调用（RPC）——比如UNIX RPC、REST API、SOAP和thrift等架构。但是这些传统的RPC实现方法有共同之处，那就是客户端和服务端强耦合（thrift不是强耦合）。客户端直接连上服务端，发送一个请求，然后停下来等待服务器的应答。这种点对点性质的模式有很多好处，它使得在小范围内的拓扑变得简单，但是这种简单的拓扑也限制了灵活性，并且当需要纵向拓展的时候，增加了复杂度。
    在RabbitMQ中，一个消息的大致流程是这样的：
    1.连接到RabbitMQ
    2.获取信道
    3.声明交换器
    4.创建消息
    5.发布消息
    6.关闭信道
    7.关闭连接
# 原理
## 生产者/消费者
	应用程序（不一定是消费者）从RabbitMQ获取的数据并不是Rabbit产生的，RabbitMQ在应用程序和服务器之间扮演者路由器的角色。所以当应用程序连接到RabbitMQ时，它必须决定：我是在发送还是在接收？或者从AMQP的角度考虑，这是一个生产者还是消费者？
	生产者（producer）创建消息，然后发布到代理服务器（RabbitMQ）。
	消费者连接到代理服务器，并订阅到队列queue上，每当消息到达特定的队列时，RabbitMQ会将其发送给其中的一个订阅的/监听的消费者。当消费者接收到消息时，它只会得到消息的一部分：有效载荷。在消息路由的过程中，消息的标签并没有随有效载荷一同传递。
## 消息
	消息包含两部分：有效载荷（payload）和标签（label），有效载荷就是你想要传输的数据，它可以是任何内容。标签描述了有效载荷，并且RabbitMQ用它来决定谁将获取消息的拷贝。
## 信道
	必须首先连接到Rabbit，才能消费或发布消息。你在应用程序和RabbitMQ代理服务器之间建立一条TCP连接。一旦打开TCP连接（已经通过认证），应用程序就可以创建一条AMQP信道。信道是建立在“真实的”TCP连接内的虚拟连接，
# QPID
